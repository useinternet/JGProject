
struct VS_IN
{
	float3 posL : POSITION;
	float2 tex : TEXCOORD;
	float3 normalL : NORMAL;
	float3 tanL : TANGENT;
	float3 bitL : BITANGENT;
};
struct VS_OUT
{
	float4 posH    : SV_POSITION;
	float3 posW    : POSITION;
	float3 posL     : LOCAL_POSITION;
	float3 normalW : NORMAL;
	float3 tanW	   : TANGENT;
	float3 bitW    : BITANGENT;
	float2 tex     : TEXCOORD;
};

__PS_SURFACE_VARIABLES_SCRIPT__
__PS_SURFACE_RESOURCES_SCRIPT__

struct PS_SURFACE_OUTPUT
{
	float4 albedo;
	float3 normal;
	float3 specular;
	float roughness;
	float metallic;
	float3 emissive;
    int flags;
};


struct PS_SURFACE_INPUT
{
	float3 position;
	float3 local_position;
	float3 normal;
	float3 tangent;
	float3 bitangent;
	float2 tex;
};


PS_SURFACE_OUTPUT PS_SURFACE_FUNCTION(PS_SURFACE_INPUT _input)
{
	PS_SURFACE_OUTPUT _output;
	_output.albedo    = float4(1.0f,1.0f,1.0f,1.0f);
	_output.specular  = float3(0.5f, 0.5f, 0.5f);
	_output.normal    = _input.normal;
    _output.roughness = 0.0f;
	_output.metallic  = 0.0f;
	_output.emissive = float3(0.0f,0.0f,0.0f);
	_output.flags = 0;

	__PS_SURFACE_FUNCTION_SCRIPT__
	return _output;
};
		
		
VS_OUT vs_main(VS_IN vin)
{
	VS_OUT vout;
	vout.posL = vin.posL;
	float3 posW = mul(float4(vin.posL, 1.0f), _WorldMatrix);
	float3 normalW = mul(float4(vin.normalL, 0.0f), _WorldMatrix);
	float3 tanW =  mul(float4(vin.tanL, 0.0f), _WorldMatrix);
	float3 bitW =  mul(float4(vin.bitL, 0.0f), _WorldMatrix);
	vout.posH = mul(float4(posW, 1.0f), _ViewProjMatrix);
	vout.posW = posW;
	vout.normalW = normalize(normalW);
	vout.tanW = normalize(tanW);
	vout.bitW = normalize(bitW);
	vout.tex   = vin.tex;
	return vout;
}


float4 Lo(VS_OUT pin, PS_SURFACE_OUTPUT output)
{
	float4 ambientLight = output.albedo * float4(0.03f, 0.03f, 0.03f, 1.0f);


	float3 N = normalize(pin.normalW);
	float3 V = normalize(_EyePosition - pin.posW);


    float3 Lo = float3(0.0f,0.0f,0.0f);

	Material material;
	material.WorldPosition = pin.posW;
	material.Albedo    = output.albedo.rgb;
	material.Roughness = output.roughness;
	material.Metallic  = output.metallic;
	material.Emissive = output.emissive;
	
	int clusterIndex = GetClusterIndex(pin.posH.xyz);
	uint3 clusterTestIndex = GetClusterIndex3(pin.posH.xyz);
	LightGrid lgrid  = _LightGridList[clusterIndex];
	if(lgrid.PL_Count > 0 && lgrid.PL_Offset >= 0)
	{
		int pl_start  = lgrid.PL_Offset;
		int pl_end    = pl_start + lgrid.PL_Count;
		for(int i = pl_start; i<pl_end; i++)
		{
			int lightIndex = _VisibleLightIndices[i];
			PointLight pl = _PointLightList[lightIndex];
			Lo += CalcPointLight(N, V, material, pl);
		}
	}


	float3 final = saturate(Lo);
	float Gamma = 1.0f / 2.2f;

    final = final / (final + float3(1.0f, 1.0f, 1.0f));
   	final = pow(final, float3(Gamma, Gamma, Gamma));
	return float4(final, 1.0f);
}

float4 ps_main(VS_OUT pin) : SV_TARGET
{
	PS_SURFACE_INPUT input;
	input.position = pin.posW;
	input.local_position = pin.posL;
	input.normal   = normalize(pin.normalW);
	input.tangent  = normalize(pin.tanW);
	input.bitangent = normalize(pin.bitW);
	input.tex       = pin.tex;
	PS_SURFACE_OUTPUT output = PS_SURFACE_FUNCTION(input);

	if(output.flags & SCRIPT_FLAG_IGNORE_LIGHTPASS)
	{
		return output.albedo;
	}
	else
	{
		return Lo(pin, output);
	}
	
}


