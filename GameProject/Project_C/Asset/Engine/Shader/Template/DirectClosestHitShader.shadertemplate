StructuredBuffer<Vertex> Local_VertexBuffer   : register(t0, space1);
StructuredBuffer<Vertex> Prev_Local_VertexBuffer   : register(t1, space1);
StructuredBuffer<uint>   Local_IndexBuffer    : register(t2, space1);


__PS_SURFACE_RESOURCES_SCRIPT__
__PS_SURFACE_VARIABLES_SCRIPT__
__PS_SURFACE_FUNCTION_SCRIPT__


SURFACE_OUTPUT SURFACE_FUNCTION(SURFACE_INPUT _input)
{
	SURFACE_OUTPUT _output;
	_output.albedo    = float4(1.0f,1.0f,1.0f,1.0f);
	_output.specular  = float3(0.5f, 0.5f, 0.5f);
	_output.normal    = _input.normal;
    _output.roughness = 0.0f;
	_output.metallic  = 0.0f;
	_output.emissive = float3(0.0f,0.0f,0.0f);
	_output.shadingmodel = 0;

	__PS_SURFACE_CONTENTS_SCRIPT__


	return _output;
};

[shader("closesthit")]
void __ClosestHit_EntryPoint__(inout DirectRayPayload payload, BuiltInTriangleIntersectionAttributes attribute)
{
	uint startIndex = PrimitiveIndex() * 3;
    const uint3 indices = { Local_IndexBuffer[startIndex], Local_IndexBuffer[startIndex + 1], Local_IndexBuffer[startIndex + 2] };

    float3 prev_vertices[3] = {
        Prev_Local_VertexBuffer[indices[0]].Position,
        Prev_Local_VertexBuffer[indices[1]].Position,
        Prev_Local_VertexBuffer[indices[2]].Position };

    float3 normals[3] = {
        Local_VertexBuffer[indices[0]].Normal,
        Local_VertexBuffer[indices[1]].Normal,
        Local_VertexBuffer[indices[2]].Normal };
		
    float3 prevHitPosition = HitAttribute(prev_vertices, attribute);
	float3 objectNormal = HitAttribute(normals, attribute);

    Vertex vertices[3] = {
        Local_VertexBuffer[indices[0]],
        Local_VertexBuffer[indices[1]],
        Local_VertexBuffer[indices[2]] };

    Vertex v = HitAttribute(vertices, attribute);

	SURFACE_INPUT input;
	input.position       = HitWorldPosition();
	input.local_position = HitObjectPosition();
	input.normal         = normalize(v.Normal);
	input.tangent        = normalize(v.Tangent);
	input.bitangent      = normalize(v.Bitangent);
	input.tex            = v.Texcoord;
	SURFACE_OUTPUT output = SURFACE_FUNCTION(input);
	
	if(output.shadingmodel == SHADING_MODEL_DEFAULT_LIT)
	{
    	payload.Hit           = RayTCurrent();
    	payload.HitPosition   = HitWorldPosition();
		
    	payload.Normal 		  = EncodeNormal(normalize(output.normal));

		float4x4  _blasTransform = _PrevFrameBottomLevelASInstanceTransform[InstanceIndex()];
		payload.PrevHitPosition = mul(float4(prevHitPosition, 1.0f), _blasTransform);
		payload.PrevNormal = EncodeNormal(normalize(mul(objectNormal, (float3x3)_blasTransform)));
		payload.Color = GGXDirect(output);
	}
	else if(output.shadingmodel == SHADING_MODEL_SKYBOX)
	{
		payload.Hit   = RayTCurrent();
		payload.Flags = PAYLOAD_FLAG_ZERO_DEPTH;
	}
	payload.Emissive = output.emissive;
}