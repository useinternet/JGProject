StructuredBuffer<Vertex> Local_VertexBuffer   : register(t0, space1);
StructuredBuffer<Vertex> Prev_Local_VertexBuffer   : register(t1, space1);
StructuredBuffer<uint>   Local_IndexBuffer    : register(t2, space1);

__PS_SURFACE_RESOURCES_SCRIPT__
__PS_SURFACE_VARIABLES_SCRIPT__
__PS_SURFACE_FUNCTION_SCRIPT__


SURFACE_OUTPUT SURFACE_FUNCTION(SURFACE_INPUT _input)
{
	SURFACE_OUTPUT _output;
	_output.albedo    = float4(1.0f,1.0f,1.0f,1.0f);
	_output.specular  = float3(0.5f, 0.5f, 0.5f);
	_output.normal    = _input.normal;
    _output.roughness = 0.0f;
	_output.metallic  = 0.0f;
	_output.emissive = float3(0.0f,0.0f,0.0f);
	_output.shadingmodel = 0;

	__PS_SURFACE_CONTENTS_SCRIPT__


	return _output;
};

[shader("closesthit")]
void __ClosestHit_EntryPoint__(inout IndirectRayPayload payload, BuiltInTriangleIntersectionAttributes attribute)
{
	uint startIndex = PrimitiveIndex() * 3;
    const uint3 indices = { Local_IndexBuffer[startIndex], Local_IndexBuffer[startIndex + 1], Local_IndexBuffer[startIndex + 2] };
    Vertex vertices[3] = {
        Local_VertexBuffer[indices[0]],
        Local_VertexBuffer[indices[1]],
        Local_VertexBuffer[indices[2]] };

    Vertex v = HitAttribute(vertices, attribute);	


	SURFACE_INPUT input;
	input.position       = HitWorldPosition();
	input.local_position = HitObjectPosition();
	input.normal         = normalize(v.Normal); 
	input.tangent        = normalize(v.Tangent); 
	input.bitangent      = normalize(v.Bitangent);
	input.tex            = v.Texcoord;
	SURFACE_OUTPUT output = SURFACE_FUNCTION(input);

	if(output.shadingmodel == SHADING_MODEL_DEFAULT_LIT)
	{
		if(payload.RayDepth < _MaxRayDepth)
		{
			float3 N = normalize(output.normal);
			float3 V = normalize(_EyePosition - input.position);
			payload.Color += GGXIndirect(
				payload.RndSeed, 
				payload.HaltonState, 
				input.position,
				N, V, output.albedo.xyz, output.roughness, payload.RayDepth);
		}
		else
		{
			float shadow = -1.0f;
			uint randSeed = 0;
			payload.Color += GGXDirect(output, shadow, randSeed);
		}
		payload.Color += output.emissive;
	}
	else
	{
		payload.Color = output.emissive;
	}
}