


cbuffer CB : register(b0)
{
    float4x4 _ViewMatrix;
    int      _PointLightCount;
    uint _NUM_X_SLICE;
    uint _NUM_Y_SLICE;
    uint _NUM_Z_SLICE;
};


// output
RWStructuredBuffer<uint>      _VisibleLightIndices : register(u0, space0);
RWStructuredBuffer<LightGrid> _LightGrids : register(u0, space1);
// input
StructuredBuffer<PointLight> _PointLights : register(t0, space2);
StructuredBuffer<Cluster>    _Clusters : register(t0, space3);



float SquardDistPointAABB(float3 p, uint clusterIndex)
{
    float result = 0.0f;
    Cluster cluster = _Clusters[clusterIndex];
    for(int i = 0; i < 3; ++i)
    {
        float v = p[i];
        if(v < cluster.Min[i])
        {
            result += (cluster.Min[i] - v) * (cluster.Min[i] - v);
        }
        if(v > cluster.Max[i])
        {
            result += (v - cluster.Max[i]) * (v - cluster.Max[i]);
        }

    }
    return result;
}
bool CheckPointLight(uint plIndex, uint tileIndex)
{
    float r = _PointLights[plIndex].Range;
    float3 p = _PointLights[plIndex].Position;
	float4 center = mul(float4(p, 1.0f), _ViewMatrix);
    float sqDist = SquardDistPointAABB(center.xyz, tileIndex);

    return sqDist <= (r * r);
}
// bool CheckSpotLightVsAABB(Spotlight spotlight, AABB aabb)
// {
//     float sphereRadius = dot(aabb.extents, aabb.extents);
//     float3 v = aabb.venter - spotlight.position;
//     float lenSq = dot(v, v);
//     float v1Len = dot(v, direction);
//     float distanceClosestPoint = cos(spotlight.angle) * sqrt(lenSq - v1Len * v1Len) - v1Len * sin(spotlight.angle);
//     bool angleCull = distanceClosestPoint > sphereRadius;
//     bool frontCull = v1Len > sphereRadius + spotlight.range;
//     bool backCull = v1Len < -sphereRadius;
//     return !(angleCull || frontCull || backCull);
// }
[numthreads(1, 1, 1)]
void cs_main(uint3 groupId : SV_GroupID,
             uint3 dispatchThreadId : SV_DispatchThreadID,
             uint3 groupThreadId    : SV_GroupThreadID,
             uint groupIndex : SV_GroupIndex)
{
    float xIndex = dispatchThreadId.x;
    float yIndex = dispatchThreadId.y;
    float zIndex = dispatchThreadId.z;
    int index = zIndex * _NUM_X_SLICE * _NUM_Y_SLICE + yIndex * _NUM_X_SLICE + xIndex;

    _LightGrids[index].PL_Count  = 0;
    _LightGrids[index].PL_Offset = 0;


    GroupMemoryBarrierWithGroupSync();


    int plCount = 0;
    int plIndices[64];

    for(int i = 0; i < _PointLightCount; i++)
    {
        bool result = CheckPointLight(i, index);
        if(result == true)
        {
            plIndices[plCount] = i;
            plCount += 1;
        }
    }

    int offset = 64 * index;
    GroupMemoryBarrierWithGroupSync();

    _LightGrids[index].PL_Count  = plCount;
    _LightGrids[index].PL_Offset = offset;

    for(int k = 0; k < plCount; k++)
    {
       _VisibleLightIndices[offset + k] = plIndices[k];
    }

}

