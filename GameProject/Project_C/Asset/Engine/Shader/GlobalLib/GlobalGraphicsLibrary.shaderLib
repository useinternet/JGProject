



cbuffer __RenderPassDataCB__ : register(b0)
{
    float4x4 _ProjMatrix;
    float4x4 _ViewMatrix;
    float4x4 _ViewProjMatrix;
    float4x4 _InvViewMatrix;
    float4x4 _InvProjMatrix;
    float4x4 _InvViewProjMatrix;
    float2   _Resolution;
    float    _NearZ;
    float    _FarZ;
    float3   _EyePosition;
    uint     _PointLightCount;
    float2   _ClusterSize;
    float    _ClusterScale;
    float    _ClusterBias;
    uint3    _NumClusterSlice;
    uint     _DebugMode;
};
cbuffer __ObjectDataCB__ : register(b1)
{
    float4x4 _WorldMatrix;
};

// Lights
StructuredBuffer<PointLight> _PointLightList : register(t0, space3);

// Clusters
StructuredBuffer<LightGrid> _LightGridList : register(t0, space11);
StructuredBuffer<uint>      _VisibleLightIndices : register(t0, space12);

// Sampler
SamplerState _PointWrap  : register(s0);
SamplerState _LinearWrap : register(s1);
SamplerState _AnisotropicWrap : register(s2);
SamplerState _PointClamp  : register(s3);
SamplerState _LinearClamp : register(s4);
SamplerState _AnisotropicClamp : register(s5);
SamplerState _LinearBorder_TB : register(s6);

// NDF
float DistributionGGX(float NoH, float r)
{
    float a      = r*r;
    float a2     = a*a;
    float NoH2 = NoH * NoH;
	
    float denom = (NoH2 * (a2 - 1.0) + 1.0);
    denom = JG_PI * denom * denom;
	
    return a2 / denom;
}

// GAF
float GeometrySchlickGGX(float r, float NoV)
{
    r = (r + 1.0);
    float k = (r*r) / 8.0;

    float num   = NoV;
    float denom = NoV * (1.0 - k) + k;
	
    return num / denom;
}
float GeometrySmith(float NoV, float NoL, float r)
{
    float ggx2  = GeometrySchlickGGX(NoV, r);
    float ggx1  = GeometrySchlickGGX(NoL, r);
	
    return ggx1 * ggx2;
}


// Fresnel
float3 F_Schlick(float cosTheta, float3 F0)
{
    if(cosTheta > 1.0f)
    {
        cosTheta = 1.0f;
    }
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}







float3 CalcDirLight(float3 N, float3 V, Material material, DirectionalLight light)
{
    float3 L = normalize(light.Direction);
    
	float3 H = normalize(L + V);


    float NoL = saturate(dot(N,L));
	float NoH = saturate(dot(N,H));
	float NoV = saturate(dot(N,V));
	float HoV = saturate(dot(H,V));


    float3 Lo = float3(0.0f,0.0f,0.0f);
    float3 F0  = lerp(float3(0.16f,0.16f,0.16f), material.Albedo, material.Metallic);
    float  D = DistributionGGX(NoH, material.Roughness);
	float  G = GeometrySmith(NoV, NoL, material.Roughness);
	float3 F = F_Schlick(HoV, F0);


    float3 numerator  = D * G * F;
	float  denom      = NoL * NoV;
	float3 specular = numerator / max(denom, 0.001f);
	float3 kS = F;
	float3 kD = float3(1.0f, 1.0f,1.0f) - kS;
	kD *= 1.0 - material.Metallic;


	Lo += (kD * material.Albedo / JG_PI + numerator) * NoL;
    return Lo;
}





float3 CalcPointLight(float3 N, float3 V, Material material, PointLight light)
{
    float3 L = normalize(light.Position - material.WorldPosition);

	float3 H = normalize(L + V);


    float NoL = saturate(dot(N,L));
	float NoH = saturate(dot(N,H));
	float NoV = saturate(dot(N,V));
	float VoH = saturate(dot(V,H));





    float3 Lo = float3(0.0f,0.0f,0.0f);
    float3 F0  = lerp(float3(0.16f,0.16f,0.16f), material.Albedo, material.Metallic);
    float  D = DistributionGGX(NoH, material.Roughness);
	float  G = GeometrySmith(NoV, NoL, material.Roughness);
	float3 F = F_Schlick(VoH, F0);


    float3 numerator  = D * G * F;
	float  denom      = 4 * NoL * NoV;
	float3 specular = numerator / max(denom, 0.0000001F);
	float3 kS = F;
	float3 kD = float3(1.0f, 1.0f,1.0f) - kS;
	kD *= 1.0 - material.Metallic;


    float att = 0.0f;
    float d  = length(light.Position - material.WorldPosition);
    if(d <= light.Range)
    {
        if(d >= light.AttRange)
        {
            d = max(d - light.AttRange, 0.0f);
            att = light.Att0 + (light.Att1 * d) + (light.Att2 * d * d);
            att = 1 / att;  
        }
        else
        {
            att = 1.0f;
        }
    
    }
    else
    {
        att = 0.0f;
    }


	Lo += (kD * material.Albedo / JG_PI + specular) * NoL;
    Lo = material.Albedo * NoL;
    return Lo * att * light.Intensity * 0.3f * light.Color;
}


float LinearDepth(float z)
{
    float depthRange = 2.0 * z - 1.0;
    return 2.0 * _NearZ * _FarZ / (_FarZ + _NearZ - depthRange * (_FarZ - _NearZ));
}
float3 CalcWorldPosition(float2 tex, float depth)
{
    float z = depth;
    float x = 2.0f * tex.x - 1.0f;
    float y = 1.0f - 2.0f * tex.y;
    float4 PosInProj = float4(x, y, z, 1.0f);
    float4 PosInWorld = mul(PosInProj, _InvViewProjMatrix);
    PosInWorld.xyz /= PosInWorld.w;
    return PosInWorld.xyz;
}
uint GetClusterIndex(float2 tex, float depth)
{
    float z = depth;
    float x = tex.x * _Resolution.x;
    float y = tex.y * _Resolution.y;
    float linearZ  = LinearDepth(z);
    uint zIndex    = max(log2(linearZ) * _ClusterScale + _ClusterBias, 0.0);

    uint3 clusterIndexs = uint3(x / _ClusterSize.x, y / _ClusterSize.y, zIndex);


    uint  tileIndex = clusterIndexs.x +
                     _NumClusterSlice.x * clusterIndexs.y +
                     (_NumClusterSlice.x * _NumClusterSlice.y) * clusterIndexs.z;
    uint tileTotalCount = _NumClusterSlice.x * _NumClusterSlice.y * _NumClusterSlice.z;
    return min(tileTotalCount, max(tileIndex, 0));
}
float3 GetClusterIndex3(float2 tex, float depth)
{
    //float x = 2.0f * tex.x - 1.0f;
    //float y = 1.0f - 2.0f * tex.y;
    float z = depth;
    float x = tex.x * _Resolution.x;
    float y = tex.y * _Resolution.y;
    float linearZ  = LinearDepth(z);
    uint zIndex    = max(log2(linearZ) * _ClusterScale + _ClusterBias, 0.0);

    uint3 clusterIndexs = uint3(x / _ClusterSize.x, y / _ClusterSize.y, zIndex);
    return float3((float)clusterIndexs.x / _NumClusterSlice.x, (float)clusterIndexs.y / _NumClusterSlice.y , (float)zIndex / 24);
}










