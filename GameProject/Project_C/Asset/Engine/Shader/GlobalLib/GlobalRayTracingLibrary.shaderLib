struct Vertex
{
	float3 Position;
	float2 Texcoord;
	float3 Normal;
	float3 Tangent;
	float3 Bitangent;
};

struct SURFACE_OUTPUT
{
	float4 albedo;
	float3 normal;
	float3 specular;
	float roughness;
	float metallic;
	float3 emissive;
    int shadingmodel;
};
struct SURFACE_INPUT
{
	float3 position;
	float3 local_position;
	float3 normal;
	float3 tangent;
	float3 bitangent;
	float2 tex;
};
struct HaltonState
{
    uint dimension;
    uint sequenceIndex;
};





float haltonSample(uint dimension, uint sampleIndex);
float haltonNext(inout HaltonState state);
uint haltonIndex(uint x, uint y, uint i);
uint halton2Inverse(uint index, uint digits);
uint halton3Inverse(uint index, uint digits);

#define RAY_DISTANCE_MIN _NearZ
#define RAY_DISTANCE_MAX _FarZ


#define INSTANCE_MASK_DIRECT 0x01
#define INSTANCE_MASK_INDIRECT 0x02
#define INSTANCE_MASK_SHADOW 0x04
#define INSTANCE_MASK_ALL 0xFF
#define INSTANCE_MASK_NOSHADOW INSTANCE_MASK_All & (~(INSTANCE_MASK_SHADOW))


//1.0e38f
#define RAY_TYPE_DIRECT   0
#define RAY_TYPE_INDIRECT 1
#define RAY_TYPE_SHADOW   2
#define RAY_TYPE_COUNT    3

#define PAYLOAD_FLAG_NONE 0
#define PAYLOAD_FLAG_ZERO_DEPTH 1

struct IndirectRayPayload
{
    float3 Color;
    uint RndSeed;
    uint RayDepth;
    HaltonState HaltonState;
};
struct DirectRayPayload
{
    float3 Color;
    float  Hit;
    float3 HitPosition;
    float2 Normal;
    float3 PrevHitPosition;
    float2 PrevNormal;
    float3 Emissive;
    float Shadow;
    uint RndSeed;
    uint Flags;
};

struct ShadowRayPayload
{
    float Factor;
};




RaytracingAccelerationStructure _SceneAS : register(t0, space0);


RWTexture2D<float4> _DirectOutput        : register(u0, space0);
RWTexture2D<float>  _IndirectRedOutput   : register(u1, space0);
RWTexture2D<float>  _IndirectGreenOutput : register(u2, space0);
RWTexture2D<float>  _IndirectBlueOutput  : register(u3, space0);
RWTexture2D<float4> _EmissiveOutput      : register(u4, space0);
RWTexture2D<float>  _ShadowOutput        : register(u5, space0);
RWTexture2D<float2> _MotionVectorOutput           : register(u6, space0);
RWTexture2D<uint>   _ReprojectedNormalDepthOutput : register(u7, space0);
RWTexture2D<uint>   _NormalDepthOutput            : register(u8, space0);
RWTexture2D<float>  _DepthOutput                  : register(u9, space0);
RWTexture2D<float4> _HitPositionOutput            : register(u10, space0); 
RWTexture2D<float4> _RayDistanceOutput            : register(u11, space0); 
// Lights

StructuredBuffer<PointLight>       _PointLightList       : register(t1, space0);
StructuredBuffer<DirectionalLight> _DirectionalLightList : register(t5, space0);
// Clusters
StructuredBuffer<LightGrid> _LightGridList       : register(t2, space0);
StructuredBuffer<uint>      _VisibleLightIndices : register(t3, space0);
StructuredBuffer<float4x4> _PrevFrameBottomLevelASInstanceTransform : register(t4, space0);


cbuffer CB : register(b0)
{
    float4x4 _ProjMatrix;
    float4x4 _ViewMatrix;
    float4x4 _ViewProjMatrix;
    float4x4 _InvViewMatrix;
    float4x4 _InvProjMatrix;
    float4x4 _InvViewProjMatrix;
    float4x4 _PrevFrameViewProjMatrix;
    float4x4 _PrevFrameInvViewProjMatrix;


    float2   _Resolution;
    float    _NearZ;
    float    _FarZ;

    float3   _EyePosition;
    uint     _PointLightCount;

    float2   _ClusterSize;
    float    _ClusterScale;
    float    _ClusterBias;

    uint3    _NumClusterSlice;
    uint     _FrameCount;
    uint     _MaxRayDepth;

    float3   _PrevFrameEyePosition;
    uint     _DirectionalLightCount;
}

SamplerState _PointWrap  : register(s0);
SamplerState _LinearWrap : register(s1);
SamplerState _AnisotropicWrap : register(s2);
SamplerState _PointClamp  : register(s3);
SamplerState _LinearClamp : register(s4);
SamplerState _AnisotropicClamp : register(s5);
SamplerState _LinearBorder_TB : register(s6);


int GetTotalLightCount()
{
    return _PointLightCount + _DirectionalLightCount;
}

///
//HitAttribute Func
///
float3 HitWorldPosition()
{
    return WorldRayOrigin() + RayTCurrent() * WorldRayDirection();
}
float3 HitObjectPosition()
{
    return ObjectRayOrigin() + RayTCurrent() * ObjectRayDirection();
}
float3 HitAttribute(float3 vertexAttribute[3], BuiltInTriangleIntersectionAttributes attr)
{
    return vertexAttribute[0] +
        attr.barycentrics.x * (vertexAttribute[1] - vertexAttribute[0]) +
        attr.barycentrics.y * (vertexAttribute[2] - vertexAttribute[0]);
}

float2 HitAttribute(float2 vertexAttribute[3], BuiltInTriangleIntersectionAttributes attr)
{
    return vertexAttribute[0] +
        attr.barycentrics.x * (vertexAttribute[1] - vertexAttribute[0]) +
        attr.barycentrics.y * (vertexAttribute[2] - vertexAttribute[0]);
}
Vertex HitAttribute(Vertex vertices[3], BuiltInTriangleIntersectionAttributes attr)
{
    float2 vertexTexcoords[3] = { vertices[0].Texcoord, vertices[1].Texcoord, vertices[2].Texcoord };
    float2 texCoord = HitAttribute(vertexTexcoords, attr);
    float orientation = HitKind() == HIT_KIND_TRIANGLE_FRONT_FACE ? 1 : -1;

    float3 vertexNormals[3] = { vertices[0].Normal, vertices[1].Normal, vertices[2].Normal };
    float3 normal = normalize(HitAttribute(vertexNormals, attr));

    normal *= orientation;
    normal = normalize(mul((float3x3)ObjectToWorld3x4(), normal));


    float3 vertexTangents[3] = { vertices[0].Tangent, vertices[1].Tangent, vertices[2].Tangent };
    float3 tangent = normalize(HitAttribute(vertexTangents, attr));
    tangent *= orientation;
    tangent = normalize(mul((float3x3)ObjectToWorld3x4(), tangent));

    float3 vertexBitangents[3] = { vertices[0].Bitangent, vertices[1].Bitangent, vertices[2].Bitangent };
    float3 bitangent = normalize(HitAttribute(vertexBitangents, attr));
    bitangent *= orientation;
    bitangent = normalize(mul((float3x3)ObjectToWorld3x4(), bitangent));



    Vertex result;
    result.Position  = HitWorldPosition();
    result.Texcoord  = texCoord;
    result.Tangent   = tangent;
    result.Bitangent = bitangent;
    result.Normal    = normal;
    return result;
}


/// Rand Function
uint initRand(uint val0, uint val1, uint backoff = 16)
{
	uint v0 = val0, v1 = val1, s0 = 0;

	[unroll]
	for (uint n = 0; n < backoff; n++)
	{
		s0 += 0x9e3779b9;
		v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
		v1 += ((v0 << 4) + 0xad90777d) ^ (v0 + s0) ^ ((v0 >> 5) + 0x7e95761e);
	}
	return v0;
}
float nextRand(inout uint s)
{
	s = (1664525u * s + 1013904223u);
	return float(s & 0x00FFFFFF) / float(0x01000000);
}




float3 getPerpendicularVector(float3 u)
{
	float3 a = abs(u);
	uint xm = ((a.x - a.y) < 0 && (a.x - a.z) < 0) ? 1 : 0;
	uint ym = (a.y - a.z) < 0 ? (1 ^ xm) : 0;
	uint zm = 1 ^ (xm | ym);
	return cross(u, float3(xm, ym, zm));
}
float3 getCosHemisphereSample(inout uint randSeed, float3 hitNorm)
{
	// Get 2 random numbers to select our sample with
	float2 randVal = float2(nextRand(randSeed), nextRand(randSeed));

	// Cosine weighted hemisphere sample from RNG
	float3 bitangent = getPerpendicularVector(hitNorm);
	float3 tangent = cross(bitangent, hitNorm);
	float r = sqrt(randVal.x);
	float phi = 2.0f * 3.14159265f * randVal.y;

	// Get our cosine-weighted hemisphere lobe sample direction
	return tangent * (r * cos(phi).x) + bitangent * (r * sin(phi)) + hitNorm.xyz * sqrt(1 - randVal.x);
}
float3 getConeSample(inout uint randSeed, float3 hitNorm, float cosThetaMax)
{
	// Get 2 random numbers to select our sample with
	float2 randVal = float2(nextRand(randSeed), nextRand(randSeed));

	// Cosine weighted hemisphere sample from RNG
	float3 bitangent = getPerpendicularVector(hitNorm);
	float3 tangent = cross(bitangent, hitNorm);

	float cosTheta = (1.0 - randVal.x) + randVal.x * cosThetaMax;
	float r = sqrt(1.0 - cosTheta * cosTheta);
	float phi = randVal.y * 2.0 * 3.14159265f;

	// Get our cosine-weighted hemisphere lobe sample direction
	return tangent * (r * cos(phi)) + bitangent * (r * sin(phi)) + hitNorm.xyz * cosTheta;
}
// Halton Func
void haltonInit(inout HaltonState hState,
    int x, int y,
    int path, int numPaths,
    int frameId,
    int loop)
{
    hState.dimension = 2;
    hState.sequenceIndex = haltonIndex(x, y,
        (frameId * numPaths + path) % (loop * numPaths));
}
float haltonSample(uint dimension, uint sampleIndex)
{
    int base = 0;

    // Use a prime number.
    switch (dimension)
    {
    case 0:  base = 2;   break;
    case 1:  base = 3;   break;
    case 2:  base = 5;   break;
    case 3:  base = 7;   break;
    case 4:  base = 11;   break;
    case 5:  base = 13;   break;
    case 6:  base = 15;   break;
    case 7:  base = 17;   break;
    case 8:  base = 19;   break;
    case 9:  base = 23;   break;
    case 10:  base = 29;   break;
    case 11:  base = 31;   break;
    case 12:  base = 37;   break;
    case 13:  base = 41;   break;
    case 14:  base = 43;   break;
    case 15:  base = 47;   break;
    case 16:  base = 53;   break;
    case 17:  base = 59;   break;
    case 18:  base = 61;   break;
    case 19:  base = 67;   break;
    case 20:  base = 71;   break;
    case 21:  base = 73;   break;
    case 22:  base = 79;   break;
    case 23:  base = 83;   break;
    case 24:  base = 89;   break;
    case 25:  base = 97;   break;
    case 26:  base = 101;   break;
    case 27:  base = 103;   break;
    case 28:  base = 109;   break;
    case 29:  base = 113;   break;
    case 30:  base = 127;   break;
    case 31: base = 131; break;
    default: base = 2;   break;
    }

    // Compute the radical inverse.
    float a = 0;
    float invBase = 1.0f / float(base);

    for (float mult = invBase;
        sampleIndex != 0; sampleIndex /= base, mult *= invBase)
    {
        a += float(sampleIndex % base) * mult;
    }

    return a;
}
float haltonNext(inout HaltonState state)
{
    return haltonSample(state.dimension++, state.sequenceIndex);
}
// Modified from [pbrt]
uint haltonIndex(uint x, uint y, uint i)
{
    return ((halton2Inverse(x % 256, 8) * 76545 +
        halton3Inverse(y % 256, 6) * 110080) % 3) + i * 186624;
}
// Modified from [pbrt]
uint halton2Inverse(uint index, uint digits)
{
    index = (index << 16) | (index >> 16);
    index = ((index & 0x00ff00ff) << 8) | ((index & 0xff00ff00) >> 8);
    index = ((index & 0x0f0f0f0f) << 4) | ((index & 0xf0f0f0f0) >> 4);
    index = ((index & 0x33333333) << 2) | ((index & 0xcccccccc) >> 2);
    index = ((index & 0x55555555) << 1) | ((index & 0xaaaaaaaa) >> 1);
    return index >> (32 - digits);
}
// Modified from [pbrt]
uint halton3Inverse(uint index, uint digits)
{
    uint result = 0;
    for (uint d = 0; d < digits; ++d)
    {
        result = result * 3 + index % 3;
        index /= 3;
    }
    return result;
}
float2 ClipSpaceToTexturePosition(in float4 clipSpacePosition)
{
    float3 NDCposition = clipSpacePosition.xyz / clipSpacePosition.w;   // Perspective divide to get Normal Device Coordinates: {[-1,1], [-1,1], (0, 1]}
    NDCposition.y = -NDCposition.y;                                     // Invert Y for DirectX-style coordinates.
    float2 texturePosition = (NDCposition.xy + 1) * 0.5f;               // [-1,1] -> [0, 1]
    return texturePosition;
}
float3 GenerateForwardCameraRayDirection(in float4x4 invViewProjMatrix)
{
	float2 screenPos = float2(0, 0);
	
	// Unproject the pixel coordinate into a world positon.
	float4 world = mul(float4(screenPos, 1, 1), invViewProjMatrix);
	return normalize(world.xyz);
}

float GetPlaneConstant(in float3 planeNormal, in float3 pointOnThePlane)
{
    // Given a plane equation N * P + d = 0
    // d = - N * P
    return -dot(planeNormal, pointOnThePlane);
}

bool IsPointOnTheNormalSideOfPlane(in float3 P, in float3 planeNormal, in float3 pointOnThePlane)
{
    float d = GetPlaneConstant(planeNormal, pointOnThePlane);
    return dot(P, planeNormal) + d > 0;
}
float3 ReflectPointThroughPlane(in float3 P, in float3 planeNormal, in float3 pointOnThePlane)
{
    //           |
    //           |
    //  P ------ C ------ R
    //           |
    //           |
    // Given a point P, plane with normal N and constant d, the projection point C of P onto plane is:
    // C = P + t*N
    //
    // Then the reflected point R of P through the plane can be computed using t as:
    // R = P + 2*t*N

    // Given C = P + t*N, and C lying on the plane,
    // C*N + d = 0
    // then
    // C = - d/N
    // -d/N = P + t*N
    // 0 = d + P*N + t*N*N
    // t = -(d + P*N) / N*N

    float d = GetPlaneConstant(planeNormal, pointOnThePlane);
    float3 N = planeNormal;
    float t = -(d + dot(P, N)) / dot(N, N);

    return P + 2 * t * N;
}

float3 ReflectFrontPointThroughPlane(
    in float3 p,
    in float3 mirrorSurfacePoint,
    in float3 mirrorNormal)
{
    if (!IsPointOnTheNormalSideOfPlane(p, mirrorNormal, mirrorSurfacePoint))
    {
        return FLT_MAX;
    }

    return ReflectPointThroughPlane(p, mirrorNormal, mirrorSurfacePoint);
}


float2 CalculateMotionVector(
    in float3 prevhitPosition,
    in float3 hitPosition,
    out float _depth,
    in uint2 DTid)
{
    // Variables prefixed with underscore _ denote values in the previous frame.
    float3 hitViewPosition = prevhitPosition - _PrevFrameEyePosition;
    float3 cameraDirection = GenerateForwardCameraRayDirection(_PrevFrameInvViewProjMatrix);
    _depth = dot(hitViewPosition, cameraDirection);

    // Calculate screen space position of the hit in the previous frame.
    float4 _clipSpacePosition = mul(float4(prevhitPosition, 1), _PrevFrameViewProjMatrix);
    float2 _texturePosition = ClipSpaceToTexturePosition(_clipSpacePosition);


    float4 clipSpacePosition = mul(float4(hitPosition, 1), _ViewProjMatrix);
    float2 texturePosition = ClipSpaceToTexturePosition(clipSpacePosition);

    float2 motionVector = (texturePosition - _texturePosition);
    return motionVector;
}

// Light Func
// NDF
float DistributionGGX(float NoH, float r)
{
    float a      = r*r;
    float a2     = a*a;
    float NoH2 = NoH * NoH;
	
    float denom = (NoH2 * (a2 - 1.0) + 1.0);
    denom = JG_PI * denom * denom;
	
    return a2 / denom;
}
// GAF
float GeometrySchlickGGX(float r, float NoV)
{
    r = (r + 1.0);
    float k = (r*r) / 8.0;

    float num   = NoV;
    float denom = NoV * (1.0 - k) + k;
	
    return num / denom;
}
float GeometrySmith(float NoV, float NoL, float r)
{
    float ggx2  = GeometrySchlickGGX(NoV, r);
    float ggx1  = GeometrySchlickGGX(NoL, r);
	
    return ggx1 * ggx2;
}
// Fresnel
float3 F_Schlick(float cosTheta, float3 F0)
{
    if(cosTheta > 1.0f)
    {
        cosTheta = 1.0f;
    }
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float CalcPointLightAtt(in PointLight pl, in float3 posW)
{
    float att = 0.0f;
    float d  = length(pl.Position - posW);
    if(d <= pl.Range)
    {
        if(d >= pl.AttRange)
        {
            d = max(d - pl.AttRange, 0.0f);
            att = pl.Att0 + (pl.Att1 * d) + (pl.Att2 * d * d);
            att = 1 / att;  
        }
        else
        {
            att = 1.0f;
        }
    }
    else
    {
        att = 0.0f;
    }
    return att;
}
float3 SurfaceShade_Default(float3 L, float3 N, float3 V, float Att, float3 Color, float Intensity, in Material material)
{
    Att = max(0, Att);
	float3 H = normalize(L + V);
    float NoL = max(dot(N,L), 0.0f);
	float NoH = max(dot(N,H),0.0f);
	float NoV = max(dot(N,V), 0.0f);
    
    float HoV = saturate(dot(H, V));
    float3 Lo = float3(0.0f,0.0f,0.0f);

    // specular default 0.5
    float3 F0  = lerp(float3(0.08f,0.08f,0.08f) * material.Specular, material.Albedo, material.Metallic);
    float  D = DistributionGGX(NoH, material.Roughness);
	float  G = GeometrySmith(NoV, NoL, material.Roughness);
	float3 F = F_Schlick(max(HoV, 0.0f), F0);

    float3 numerator  = D * G * F;
	//float  denom      = 4 * NoL * NoV;
	float3 specular = numerator;// / max(denom, 0.0000001F);
	float3 kS = F;
	float3 kD = float3(1.0f, 1.0f,1.0f) - kS;
	kD *= 1.0 - material.Metallic;
	Lo += (kD * material.Albedo / JG_PI + specular) * NoL;
    return Lo * Att * Intensity * Color;
}



float LinearDepth(float z)
{
    float depthRange = 2.0 * z - 1.0;
    return 2.0 * _NearZ * _FarZ / (_FarZ + _NearZ - depthRange * (_FarZ - _NearZ));
}
uint GetClusterIndex(float3 posW)
{
    float4 posH  = mul(float4(posW, 1.0f), _ViewProjMatrix);
    float  depth = posH.z / posH.w;
    float2 tex   = float2(DispatchRaysIndex().xy) / DispatchRaysDimensions().xy; 




    float z = depth;
    float x = tex.x * _Resolution.x;
    float y = tex.y * _Resolution.y;
    float linearZ  = LinearDepth(z);
    uint zIndex    = max(log2(linearZ) * _ClusterScale + _ClusterBias, 0.0);

    uint3 clusterIndexs = uint3(x / _ClusterSize.x, y / _ClusterSize.y, zIndex);


    uint  tileIndex = clusterIndexs.x +
                     _NumClusterSlice.x * clusterIndexs.y +
                     (_NumClusterSlice.x * _NumClusterSlice.y) * clusterIndexs.z;
    uint tileTotalCount = _NumClusterSlice.x * _NumClusterSlice.y * _NumClusterSlice.z;
    return min(tileTotalCount, max(tileIndex, 0));
}
float3 ImportanceSampleGGX(float2 Xi, float3 N, float roughness)
{
	float a = roughness * roughness;

	float phi = 2.0 * 3.1415826 * Xi.x;
	float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
	float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

	// from spherical coordinates to cartesian coordinates
	float3 H;
	H.x = cos(phi) * sinTheta;
	H.y = sin(phi) * sinTheta;
	H.z = cosTheta;

	// from tangent-space vector to world-space sample vector
	float3 up = abs(N.z) < 0.999 ? float3(0.0, 0.0, 1.0) : float3(1.0, 0.0, 0.0);
	float3 tangent = normalize(cross(up, N));
	float3 bitangent = cross(N, tangent);

	float3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;
	return normalize(sampleVec);
}
float3 ShootIndirectRay(
    float3 rayOrigin, 
    float3 rayDir, 
    inout uint seed, 
    HaltonState hState, uint curDepth)
{
	RayDesc ray;
	ray.Origin = rayOrigin;  // Where does it start?
	ray.Direction = rayDir;  // What direction do we shoot it?
	ray.TMin = RAY_DISTANCE_MIN;            // The closest distance we'll count as a hit
	ray.TMax = RAY_DISTANCE_MAX;      // The farthest distance we'll count as a hit

	IndirectRayPayload payload;
	payload.Color       = float3(0, 0, 0);
	payload.RndSeed     = seed;
	payload.RayDepth    = curDepth + 1;
	payload.HaltonState = hState;

	TraceRay(
        _SceneAS, 
        RAY_FLAG_NONE, 
        INSTANCE_MASK_INDIRECT, 
        RAY_TYPE_INDIRECT, 
        RAY_TYPE_COUNT, 
        RAY_TYPE_INDIRECT, 
        ray, 
        payload);

	return payload.Color;
}

float3 ShootDirectRay(
    float3 rayOrigin, 
    float3 rayDir,
    out float3 hitPosition,
    uint randSeed)
{
    RayDesc ray;
    ray.Origin = rayOrigin;  
	ray.Direction = rayDir; 
	ray.TMin = RAY_DISTANCE_MIN;           
	ray.TMax = RAY_DISTANCE_MAX;

    DirectRayPayload payload;
    payload.Color = float3(0.0f,0.0f,0.0f);
    payload.Hit = 0.0f;
    payload.HitPosition = float3(0,0,0);
    payload.Normal = float2(0,0);
    payload.PrevHitPosition = float3(0,0,0);
    payload.PrevNormal = float2(0,0);
    payload.Emissive = float3(0,0,0);
    payload.Flags = PAYLOAD_FLAG_NONE;
    payload.Shadow  = 1.0f;
    payload.RndSeed = randSeed;
    TraceRay(
        _SceneAS,
        RAY_FLAG_NONE,
        INSTANCE_MASK_DIRECT,
        RAY_TYPE_DIRECT,
        RAY_TYPE_COUNT,
        RAY_TYPE_DIRECT,
        ray,
        payload);

    uint2  launchIndex = DispatchRaysIndex().xy;
    float _depth;

    _EmissiveOutput[launchIndex]   = float4(payload.Emissive, 1.0f);
    _HitPositionOutput[launchIndex] =float4(payload.HitPosition,1.0f);
    _ShadowOutput[launchIndex]      = payload.Shadow;
    if(payload.Hit == 0.0f)
    {
        _MotionVectorOutput[launchIndex] = float2(1e3f,1e3f);
        _ReprojectedNormalDepthOutput[launchIndex] = 0;
        _NormalDepthOutput[launchIndex] = 0;
        _DepthOutput[launchIndex]       = 0;
        _RayDistanceOutput[launchIndex] = _FarZ;
    }
    else
    {
        float2 motionVector = CalculateMotionVector(payload.PrevHitPosition,payload.HitPosition, _depth, launchIndex);
        _MotionVectorOutput[launchIndex] = motionVector;
        _ReprojectedNormalDepthOutput[launchIndex] = EncodeNormalDepth(DecodeNormal(payload.PrevNormal), _depth);

    // Calculate linear z-depth
        float  rayLength   = payload.Hit;
        float3 eyeDir      = GenerateForwardCameraRayDirection(_InvViewProjMatrix);
        float  linearDepth = rayLength * dot(rayDir, eyeDir);

        
        _NormalDepthOutput[launchIndex] = EncodeNormalDepth(DecodeNormal(payload.Normal), linearDepth);
        _DepthOutput[launchIndex]       = linearDepth;
        _RayDistanceOutput[launchIndex] = payload.Hit;
    }

    if(payload.Flags == PAYLOAD_FLAG_ZERO_DEPTH)
    {
        _DepthOutput[launchIndex] = 0.0f;
    }


    hitPosition = payload.HitPosition;
    return payload.Color;
}
float ShootShadowRay_DL(DirectionalLight dl, inout uint randSeed, float3 worldPos)
{
    ShadowRayPayload payload;
    payload.Factor = 0.0F;
    float3 L = normalize(dl.Direction);
    float3 lightPos  = _EyePosition + -L * _FarZ * 0.5f;
    float  distance  = length(lightPos - worldPos);
    float3 direction = normalize(lightPos - worldPos);
    if(distance <= _FarZ)
    {
        RayDesc ray;
        ray.Origin    = worldPos;
        ray.Direction = normalize(getConeSample(randSeed, normalize(direction) , 0.9999));;
        ray.TMin = 0.01f;
        ray.TMax = distance;
            TraceRay(
            _SceneAS,
        	RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER,
            INSTANCE_MASK_SHADOW,
            RAY_TYPE_SHADOW, 
            RAY_TYPE_COUNT,
            RAY_TYPE_SHADOW, 
            ray,
            payload);
    }
    else
    {
        return 1.0f;
    }


    return payload.Factor;
}
float ShootShadowRay_PL(PointLight pl, inout uint randSeed, float3 worldPos)
{
    float  distance  = length(pl.Position - worldPos);
   	float3 direction = normalize(pl.Position - worldPos);

    ShadowRayPayload payload;
    payload.Factor = 0.0f;

    if(distance <= pl.Range)
    {
        RayDesc ray;
        ray.Origin    = worldPos;
        ray.Direction = normalize(getConeSample(randSeed,direction , 0.9999));;
        ray.TMin = 0.01;
        ray.TMax = distance;
        TraceRay(
        	_SceneAS,
        	RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER,
        	INSTANCE_MASK_SHADOW,
        	RAY_TYPE_SHADOW, 
        	RAY_TYPE_COUNT,
        	RAY_TYPE_SHADOW, 
        	ray,
        	payload);
            // Shadow att apply
    }
    else
    {
        return 1.0f;
    }

    return payload.Factor;
}

float3 LambertianIndirect(
    inout uint seed, 
    HaltonState hState, 
    float3 hit, 
    float3 N, 
    float3 Albedo, 
    uint rayDepth)
{
	float3 L = getCosHemisphereSample(seed, N);
	float3 bounceColor = ShootIndirectRay(hit, L, seed, hState, rayDepth);
	return bounceColor * Albedo;
}
float3 GGXIndirect(
    inout uint seed, 
    HaltonState hState, 
    float3 hit, 
    float3 N, 
    float3 V, 
    float3 Albedo,
    float R, 
    uint rayDepth)
{
    R = 1.0f - R;
	if (frac(haltonNext(hState) + nextRand(seed)) > R)
	{
		return LambertianIndirect(seed, hState, hit, N, Albedo, rayDepth);
	}
	else
	{
		float rnd1 = frac(haltonNext(hState) + nextRand(seed));
		float rnd2 = frac(haltonNext(hState) + nextRand(seed));
		float2 Xi = float2(rnd1, rnd2);
		float3 H = ImportanceSampleGGX(Xi, N, 1.0 - R);
		float3 L = normalize(2.0 * dot(V, H) * H - V);

		float3 bounceColor = ShootIndirectRay(hit, L, seed, hState, rayDepth);
		return bounceColor;
	}
}
float3 GGXDirect(SURFACE_OUTPUT input, inout float output_shadow, inout uint randSeed)
{
    float3 posW = HitWorldPosition();
    float3 Lo = float3(0.0f,0.0f,0.0f);
	float3 N = normalize(input.normal);
	float3 V = normalize(_EyePosition - posW);
    

    Material material;
    material.Albedo = input.albedo;
    material.Roughness = input.roughness;
    material.Metallic = input.metallic;
    material.Emissive = input.emissive;
    material.Specular = input.specular;
    material.WorldPosition = posW;

    bool  isCalcShadow = output_shadow != -1.0f;
    float accIntensity = 0.000001f;
    float accShadowIntensity = 0.0f;


    //Calc DirectionalLight
    // int i = 0;
    int DL_Count = max(_DirectionalLightCount, 0);
    if(DL_Count > 0)
    {
        DirectionalLight dl = _DirectionalLightList[0];
        float3 L    = normalize(-dl.Direction);
        float3 dlLo = SurfaceShade_Default(L, N, V, 1.0f, dl.Color, dl.Intensity, material);
        Lo += dlLo;
        if(isCalcShadow == true)
        {
            float intensity = max(max(dlLo.x,dlLo.y),dlLo.z);
            accIntensity += intensity;

            float shadow = ShootShadowRay_DL(dl, randSeed, posW);
            accShadowIntensity += (intensity * shadow);
        }
    }

    uint   clusterIndex = GetClusterIndex(posW);
	LightGrid lgrid  = _LightGridList[clusterIndex];

	// Calc PointLight
	if(lgrid.PL_Count > 0 && lgrid.PL_Offset >= 0)
	{
		int pl_start  = lgrid.PL_Offset;
		int pl_end    = pl_start + lgrid.PL_Count;
		for(int i = pl_start; i<pl_end; i++)
		{
			int lightIndex = _VisibleLightIndices[i];
    
			PointLight pl = _PointLightList[lightIndex];
            float3 L  = normalize(pl.Position - posW); 
            float att = CalcPointLightAtt(pl, posW);
            float3 plLo = SurfaceShade_Default(L, N, V, att, pl.Color, pl.Intensity, material);
			Lo += plLo;
            if(isCalcShadow == true)
            {
                float intensity = max(max(plLo.x,plLo.y),plLo.z);
                accIntensity += intensity;
                float shadow = ShootShadowRay_PL(pl, randSeed, posW);
                accShadowIntensity += (intensity * shadow);
            }
		}
	}
    if(isCalcShadow == true)
    {
        output_shadow = accShadowIntensity / accIntensity;
    }

    return Lo;
};


[shader("closesthit")]
void ShadowHit(inout ShadowRayPayload payload, BuiltInTriangleIntersectionAttributes attribute)
{
    payload.Factor = 0.0f;
}
[shader("miss")]
void ShadowMiss(inout ShadowRayPayload payload : SV_RayPayload)
{
    payload.Factor = 1.0f;
}

