
_Resources{
	Texture2D SceneTexture;
    Texture2D LensDirt;
};
_Variables {


};

_Scene {

    float2 uv = _input.tex;
    float4 sceneColor = SceneTexture.Sample(_LinearClampSampler, _input.tex);
    
    _output.final.rgb = Gaussion(uv);
    _output.final.a   = sceneColor.a;


    if(Bloom_Only)
    {
        _output.final.xyz = Blend(sceneColor.rgb, _output.final.rgb);
    }
};

_Function{

    static const float Bloom_Threshold = 0.7f;
    static const float Bloom_Intensity = 2.5f;
    static const float Blur_Iterations = 5;
    static const float Blur_Size = 0.03f;
    static const int Blur_Subdivisions = 32;
    static const int Lens_Dirt = 0;
    static const float Dirt_Intensity = 2.5f;
    static const int Bloom_Only = 0;

float3 Blend(float3 a, float3 b) {
 
    return float3(1.0f,1.0f,1.0f) - (float3(1.0f,1.0f,1.0f) - a)*(float3(1.0f,1.0f,1.0f) - b);
    
}


float3 GetHDR(float3 tex)
{
 
    return max((tex - Bloom_Threshold) * Bloom_Intensity, float3(0.0f, 0.0f, 0.0f));
    
}

float3 Gaussion(float2 uv)
{
    float3 sum = float3(0.0f,0.0f,0.0f);

    for(int i = 1; i<=Blur_Iterations; ++i)
    {
        float angle = 360.0f / (float)Blur_Subdivisions;

        for(int j = 0; j < Blur_Subdivisions; ++j)
        {
            float dist = Blur_Size * ((float)(i+1) / (float)Blur_Iterations);
            float s    = sin(angle * (float)j);
            float c	   = cos(angle * (float)j);

            if(Lens_Dirt == 0)
            {
                sum += GetHDR(SceneTexture.Sample(_LinearClampSampler, uv + float2(c,s)*dist).rgb);
            }
            else
            {
                float3 dirt = LensDirt.Sample(_LinearSampler, uv).rgb * Dirt_Intensity;
                sum += GetHDR(SceneTexture.Sample(_LinearClampSampler, uv + float2(c,s)*dist).rgb) * dirt;
            }
        }

    }

    sum /= (float)(Blur_Iterations * Blur_Subdivisions);

    return sum;
}

};