
_Resources{
	Texture2D GBuffer_Albedo;
	Texture2D GBuffer_Normal;
	Texture2D GBuffer_WorldPos;
	Texture2D GBuffer_Specular;
	Texture2D GBuffer_Emissive;
	Texture2D GBuffer_Material_0;
	Texture2D GBuffer_Depth;
};

_Variables {

};

_Scene {
	float3 albedo     = GBuffer_Albedo.Sample(_LinearWrap, _input.tex).rgb;
	float3 normal     = normalize(GBuffer_Normal.Sample(_LinearWrap, _input.tex).xyz);
	float3 specular   = GBuffer_Specular.Sample(_LinearWrap, _input.tex).xyz;
	float3 emissive   = GBuffer_Emissive.Sample(_LinearWrap, _input.tex).xyz;
	float4 material_0 = GBuffer_Material_0.Sample(_LinearWrap, _input.tex);
	float depth 	  = saturate(GBuffer_Depth.Sample(_LinearWrap, _input.tex).r);

	
	



	Material material;
	material.WorldPosition = GBuffer_WorldPos.Sample(_LinearWrap, _input.tex).xyz;//CalcWorldPosition(_input.tex,  saturate(depth));
	material.Albedo 	   = albedo;
	material.Emissive 	   = emissive;
	material.Roughness 	   = material_0.r;
	material.Metallic 	   = material_0.g;
	float3 Lo = float3(0.0f,0.0f,0.0f);
	float3 N = normalize(normal);
	float3 V = normalize(_EyePosition - material.WorldPosition);


	int   clusterIndex = GetClusterIndex(_input.tex, depth);
	LightGrid lgrid  = _LightGridList[clusterIndex];

	// Calc PointLight
	if(lgrid.PL_Count > 0 && lgrid.PL_Offset >= 0)
	{
		int pl_start  = lgrid.PL_Offset;
		int pl_end    = pl_start + lgrid.PL_Count;
		for(int i = pl_start; i<pl_end; i++)
		{
			int lightIndex = _VisibleLightIndices[i];
			PointLight pl = _PointLightList[lightIndex];
			Lo += CalcPointLight(N, V, material, pl);
		}
	}
	_output.final = float4(Lo + emissive, 1.0f);
};

_Function {

};